---
title: "COMA Vignette"
author: "Jeff Endelman"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{COMA Vignette1}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE,message=FALSE,warning=FALSE,comment="##",
                      dpi=150)
opts_knit$set(root.dir="~/Box Sync/Endelman/Software/COMA")
warnings(-1)
```

COMA requires two input files. The first file contains the marker effects and allele dosage data for the parental candidates. Dominance marker effects are optional, but when included should correspond to a breeding value parameterization, including the effect of heterosis/inbreeding depression [(Endelman 2023)](https://doi.org/10.1007/s00122-023-04298-x). The `blup` command in [R/StageWise](https://github.com/jendelman/StageWise) is one option to compute marker effects. 

The vignette dataset comes from the University of Wisconsin potato breeding program. There are 170 tetraploid clones genotyped at 12K markers, and the marker effects are derived from a multi-trait index.

```{r}
geno.file <- system.file("vignette_data", "geno.csv", package = "COMA")
geno <- read.csv(geno.file,check.names=F)
geno[1:4,1:5]
```

The second input file is the kinship matrix to control inbreeding. Based on simulation results (Endelman 2024), the pedigree (IBD) kinship matrix is recommended for either OCS or OMA. (Do not use the typical G matrix from genomic selection.) A pedigree kinship matrix is provided for the potato clones, estimated using R package [AGHmatrix](https://cran.r-project.org/web/packages/AGHmatrix/index.html).

```{r,fig.width=4,fig.height=4}
K.file <- system.file("vignette_data", "kinship.csv", package = "COMA")

#preview files
K <- as.matrix(read.csv(K.file,check.names=F,row.names=1))
K[1:3,1:3]
```

Now we are ready for `read_data`:

```{r}
library(COMA)
data <- read_data(geno.file=geno.file,
                  kinship.file=K.file,
                  ploidy=4, matings="all",
                  standardize=TRUE, n.core=2)

head(data$parents)
head(data$matings)
```

The `matings` argument for `read_data` indicates how to create the table of possible matings. The above example used "all", which creates all unique parental combinations. Consult the [function documentation](https://jendelman.github.io/COMA/manual.pdf) for other options. When argument `standardize` is TRUE, the trait is centered and scaled so that the parental population has zero mean and unit variance. This is for convenience when interpreting the response values.

As shown above, the `parents` output contains the predicted merit (GEBV) for each individual. The `matings` output contains the predicted merit (F1 progeny mean) for each possible mating. For dioecious species (with separate sexes), a data frame with sex information is needed as argument `sex` in `read_data`, and the column headers for the matings are "female","male" instead of "parent1","parent2". 

### OCS and OMA

The `ocs` and `oma` functions are used to determine the optimal genetic contributions. Both require the argument `parents`, which must specify the minimum and maximum contributions. In this case we used min=0 and max=1 for all parents, but this can be tailored to each parent. For `oma`, the parental merits are not used, so this column is omitted. Rather, the merit of each mating is needed, along with its min and max. Based on simulation results and long-standing practice in animal breeding, inbreeding rates of 0.005 (0.5%) to 0.01 (1%) are recommended. However, this may not be feasible depending on the relatedness of the parents. As the results below show, the smallest feasible inbreeding rate was 1.5% for OCS and 1% for OMA.

```{r}
parents <- data.frame(data$parents, min=0, max=1)

ocs1 <- ocs(dF=0.005, parents=parents, ploidy=4, K=data$K)
ocs2 <- ocs(dF=0.010, parents=parents, ploidy=4, K=data$K)
ocs3 <- ocs(dF=0.015, parents=parents, ploidy=4, K=data$K)
kable(rbind(ocs1$response, ocs2$response, ocs3$response),digits=3)

matings <- data.frame(data$matings, min=0, max=1)

oma1 <- oma(dF=0.005, parents=parents[,-2], matings=matings, ploidy=4, K=data$K)
oma2 <- oma(dF=0.010, parents=parents[,-2], matings=matings, ploidy=4, K=data$K)
oma3 <- oma(dF=0.015, parents=parents[,-2], matings=matings, ploidy=4, K=data$K)
kable(rbind(oma1$response, oma2$response, oma3$response), digits=3)
```

The above results show the predicted merit and Shannon diversity for the optimized parental contributions. The predicted merit for OMA includes heterosis while OCS does not. For both methods, higher inbreeding leads to higher merit and lower diversity, which is an expected trade-off. 

The dF values in the output are the realized inbreeding rates, which can exceed the target due to thresholding (see below). The `oma` function returns two rates, dF1 and dF2. dF1 is the inbreeding rate for the next generation, and dF2 is the effective inbreeding rate over two generations if random mating were to occur among the progeny. This constraint is analogous to the group coancestry constraint in OCS (Endelman 2024). As the example shows, dF2 is typically at the limit while dF1 is not. 

Now let's examine the optimum contributions, which are returned as `oc` for the parental contributions in both functions. The optimal mate allocations are returned as `om` by `oma`.

```{r}
kable(oma2$oc[1:5,], digits=3)
kable(oma2$om[1:5,], digits=3)
```

Many contributions/allocations are very small (rounding to 0.000). In practice, there will be some minimum contribution/allocation that a breeding program can realize. For example, in the UW-Madison potato breeding program, approximately 20,000 progeny seedlings are generated per year per product profile. We like to work with at least 100 offspring per family, which corresponds to a minimum mate allocation of 100/20,000 = 0.5%. These practical constraints are enforced after the optimization by setting all values below the minimum to zero, which can generate realized inbreeding rates above the target. The following code illustrates the `min.a` parameter for `oma` (corresponding paramter is `min.c` for `ocs`).

```{r}
oma2b <- oma(dF=0.01, parents=parents[,-2], matings=matings, ploidy=4, 
             K=data$K, min.a=0.005)
oma2b$response
kable(oma2b$om[1:5,],digits=3)
```

Here is code to quickly explore a range of inbreeding rates, using the `lapply` command:

```{r}
dF <- seq(1,2.5,by=0.5)/100
ans <- lapply(as.list(dF), oma, parents=parents[,-2], matings=matings, 
              ploidy=4, K=data$K, min.a=0.005)
response <- t(sapply(ans,"[[",1))
kable(response, digits=3)
```

The `plot_ribbon` command produces ribbon plots of the optimal contributions or allocations. 

```{r,fig.width=5,fig.height=4}
oc <- lapply(ans,"[[",'oc')
names(oc) <- dF
plot_ribbon(oc)
```

```{r,fig.width=6,fig.height=4}
library(ggplot2)
f <- function(z){data.frame(id=apply(z$om[,1:2],1,paste,collapse="/"),
                            value=z$om$value)}
om <- lapply(ans,f)
names(om) <- dF
plot_ribbon(om) + ylab("Allocation") + 
  theme(axis.text.x = element_text(angle=90,vjust=0.5))
```

### Other Constraints

Because COMA is based on convex optimization, additional linear constraints can be incorporated. The potato dataset contains presence/absence information for a genetic marker for potato virus Y resistance (PVYR), which is a critical trait. Two different selection approaches will be illustrated: (1) only allowing matings with a resistant parent; (2) imposing a lower bound on the R gene frequency. 

The following code implements method 1:

```{r}
library(dplyr)
par.file <- system.file("vignette_data", "parents.csv", 
                          package = "COMA")
data2 <- read.csv(par.file)
PVYR.id <- data2$id[data2$PVYR=="Y"]

#constraint method 1
con1 <- oma(dF=0.01, ploidy=4L, K=data$K, min.a=0.005,
            parents=parents[,-2], 
            matings=filter(matings, parent1%in%PVYR.id | parent2%in%PVYR.id))

#calculate proportion of matings with PVYR parent from previous solution
n.mate <- nrow(ans[[1]]$om)
nR <- sum(ans[[1]]$om$parent1 %in% PVYR.id | ans[[1]]$om$parent2 %in% PVYR.id)

#calculate frequency of PVYR gene, assuming single copy in parents
Ry.freq <- ifelse(ans[[1]]$oc$id %in% PVYR.id, 0.25, 0)
freq0 <- sum(ans[[1]]$oc$value * Ry.freq)
Ry.freq <- ifelse(con1$oc$id %in% PVYR.id, 0.25, 0)
freq1 <- sum(con1$oc$value * Ry.freq)

result <- data.frame(constraint=c("none","method 1"),
                     rbind(ans[[1]]$response,con1$response),
                     prop.resistant.matings=c(nR/n.mate,1),
                     Ry.freq=c(freq0,freq1))
kable(result,digits=3)
```

The above table compares the solution with and without the PVYR constraint. As expected, increasing the proportion of PVYR matings from 41% to 100% reduced the predicted merit. The frequency of the R gene in the progeny is also shown, assuming a single copy in the resistant parents. When 100% of the matings have 1 PVYR parent, the gene frequency is 1/8 = 0.125.

Under method 2, the R gene frequency is constrained directly, which is less restrictive than method 1 because some matings could have two PVYR parents while others have none. Both `ocs` and `oma` allow linear inequality or equality constraints on any linear combination of the parental contributions. When the coefficients, $\mathbf{s}$, of the contribution variables, $\mathbf{y}$, are the R gene frequencies of each parent, this creates the desired constraint. The coefficients are included as an additional column in the `parents` data.frame, and the column header is parsed to complete the equation. In this case, the header "gt0.125" represents greater than or equal to 0.125:
$$ \mathbf{s}^\prime \mathbf{y} \ge 0.125$$

```{r}
parents2 <- data.frame(parents,
                       gt0.125=ifelse(parents$id %in% PVYR.id, 0.25, 0))

con2 <- oma(dF=0.01, ploidy=4L, K=data$K, min.a=0.005,
            parents=parents2[,-2], matings=matings)

Ry.freq <- ifelse(con2$oc$id %in% PVYR.id, 0.25, 0)
freq2 <- sum(con2$oc$value * Ry.freq)

result <- data.frame(constraint=c("none","method 1","method 2"),
                     rbind(ans[[1]]$response,con1$response,con2$response),
                     Ry.freq=c(freq0,freq1,freq2))
kable(result,digits=3)
```

As expected, the merit under method 2 was higher than method 1.
